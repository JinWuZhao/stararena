// Const Declarations
const int c_unitPlayerAIStatesCap = 5;

const int c_unitPlayerPropsMaxLife = 0;
const int c_unitPlayerPropsDamageMultiplier = 1;
const int c_unitPlayerPropsRangeMultiplier = 2;
const int c_unitPlayerPropsMoveSpeed = 3;
const int c_unitPlayerPropsAttackSpeed = 4;
const int c_unitPlayerPropsCap = 5;

const int c_UnitPlayerMaxLevel = 15;

const int c_unitPlayersCap = 40;

const int c_GameStatePlayerIdRed = 4;
const int c_GameStatePlayerIdBlue = 3;

struct UnitPlayerBuff {
    string behavior;
    int count;
    fixed duration;
    datetime ctime;
};
typedef structref<UnitPlayerBuff> UnitPlayerBuffRef;

const int c_UnitPlayerBuffsCap = 10;

// Type Declarations
struct UnitPlayer {
    string name;
    string unitType;
    string weaponType;
    string abilityType;
    datetime deadTime;
    int reviveInterval;
    int playerId;
    int score;
    int combo;
    int exp;
    int points;
    int aiMode;
    int level;
    int revivePoint;
    bool isBot;
    int[c_unitPlayerAIStatesCap] aiStates;
    int[c_unitPlayerPropsCap] props;
    UnitPlayerBuff[c_UnitPlayerBuffsCap] buffs;
};

typedef structref<UnitPlayer> UnitPlayerRef;

typedef UnitPlayer[c_unitPlayersCap] UnitPlayerArray;
typedef arrayref<UnitPlayerArray> UnitPlayerArrayRef;

// Variable Declarations
static UnitPlayerArray gv_gamestate_unitPlayers;
static int gv_gamestate_unitPlayersCount;
static int gv_gamestate_unitPlayerIndexOfName;

// Function Declarations
bool AddUnitPlayer(UnitPlayerRef player);
bool RemoveUnitPlayer(string name);
bool SaveUnitPlayer(UnitPlayerRef player);
bool UnitPlayerFromName(string name, UnitPlayerRef player);
bool UnitPlayerGet(int inIndex, UnitPlayerRef player);
void UnitPlayersGetAll(UnitPlayerArrayRef outPlayers);
int UnitPlayersCount();
void UnitPlayersOfRanked(UnitPlayerArrayRef outPlayers);
void UnitPlayerAddBuff(UnitPlayerRef refPlayer, UnitPlayerBuffRef inBuff);
void UnitPlayerSaveBuffs(UnitPlayerRef refPlayer);
void UnitPlayerRestoreBuffs(UnitPlayerRef refPlayer, unit inUnit);
int UnitPlayerGetMinLevel();
void InitGameState();

static void gamestate_InitUnitPlayerIndexOfName();
static void gamestate_CopyUnitPlayer(UnitPlayerRef dest, UnitPlayerRef source);
static int gamestate_PickAvailableUnitPlayerIndex(int playerId);
static void gamestate_SaveUnitPlayerByIndex(int index, UnitPlayerRef player);

// Functions
static void gamestate_InitUnitPlayerIndexOfName() {
    DataTableInstanceCreate();
    gv_gamestate_unitPlayerIndexOfName = DataTableInstanceLastCreated();
}

static void gamestate_CopyUnitPlayer(UnitPlayerRef dest, UnitPlayerRef source) {
    int lv_index;

    dest.name = source.name;
    dest.playerId = source.playerId;
    dest.exp = source.exp;
    dest.points = source.points;
    dest.score = source.score;
    dest.unitType = source.unitType;
    dest.weaponType = source.weaponType;
    dest.abilityType = source.abilityType;
    dest.deadTime = source.deadTime;
    dest.reviveInterval = source.reviveInterval;
    dest.aiMode = source.aiMode;
    dest.level = source.level;
    dest.combo = source.combo;
    dest.revivePoint = source.revivePoint;
    dest.isBot = source.isBot;
    for (lv_index = 0; lv_index < c_unitPlayerAIStatesCap; lv_index += 1) {
        dest.aiStates[lv_index] = source.aiStates[lv_index];
    }
    for (lv_index = 0; lv_index < c_unitPlayerPropsCap; lv_index += 1) {
        dest.props[lv_index] = source.props[lv_index];
    }
    for (lv_index = 0; lv_index < c_UnitPlayerBuffsCap; lv_index += 1) {
        dest.buffs[lv_index].behavior = source.buffs[lv_index].behavior;
        dest.buffs[lv_index].count = source.buffs[lv_index].count;
        dest.buffs[lv_index].duration = source.buffs[lv_index].duration;
        dest.buffs[lv_index].ctime = source.buffs[lv_index].ctime;
    }
}

static int gamestate_PickAvailableUnitPlayerIndex(int playerId) {
    int index = 0;

    if (playerId == c_GameStatePlayerIdRed) {
        index = 0;
    } else if (playerId == c_GameStatePlayerIdBlue) {
        index = c_unitPlayersCap / 2;
    }
    for (; index < c_unitPlayersCap; index += 1) {
        if (gv_gamestate_unitPlayers[index].name == null) {
            break;
        }
    }
    return index;
}

static void gamestate_SaveUnitPlayerByIndex(int index, UnitPlayerRef player) {
    gamestate_CopyUnitPlayer(gv_gamestate_unitPlayers[index], player);
    DataTableInstanceSetInt(gv_gamestate_unitPlayerIndexOfName, player.name, index);
}

bool AddUnitPlayer(UnitPlayerRef player) {
    int index = gamestate_PickAvailableUnitPlayerIndex(player.playerId);
    if (index == c_unitPlayersCap) {
        return false;
    }
    gamestate_SaveUnitPlayerByIndex(index, player);
    gv_gamestate_unitPlayersCount += 1;
    return true;
}

bool RemoveUnitPlayer(string name) {
    UnitPlayer emptyPlayer;

    if (!DataTableInstanceValueExists(gv_gamestate_unitPlayerIndexOfName, name)) {
        return false;
    }
    gamestate_CopyUnitPlayer(gv_gamestate_unitPlayers[DataTableInstanceGetInt(gv_gamestate_unitPlayerIndexOfName, name)], emptyPlayer);
    DataTableInstanceValueRemove(gv_gamestate_unitPlayerIndexOfName, name);
    gv_gamestate_unitPlayersCount -= 1;
    return true;
}

bool SaveUnitPlayer(UnitPlayerRef player) {
    UnitPlayerRef lv_player;

    if (!DataTableInstanceValueExists(gv_gamestate_unitPlayerIndexOfName, player.name)) {
        return false;
    }

    lv_player = gv_gamestate_unitPlayers[DataTableInstanceGetInt(gv_gamestate_unitPlayerIndexOfName, player.name)];
    gamestate_CopyUnitPlayer(lv_player, player);
    return true;
}

bool UnitPlayerFromName(string name, UnitPlayerRef player) {
    UnitPlayerRef lv_player;

    if (!DataTableInstanceValueExists(gv_gamestate_unitPlayerIndexOfName, name)) {
        return false;
    }

    lv_player = gv_gamestate_unitPlayers[DataTableInstanceGetInt(gv_gamestate_unitPlayerIndexOfName, name)];
    gamestate_CopyUnitPlayer(player, lv_player);
    return true;
}

bool UnitPlayerGet(int inIndex, UnitPlayerRef outPlayer) {
    UnitPlayerRef lv_player;

    if (inIndex < 0 || inIndex >= c_unitPlayersCap) {
        return false;
    }
    lv_player = gv_gamestate_unitPlayers[inIndex];
    if (arena_gf_StringIsEmpty(lv_player.name)) {
        return false;
    }
    gamestate_CopyUnitPlayer(outPlayer, lv_player);
    return true;
}

int UnitPlayersCount() {
    return gv_gamestate_unitPlayersCount;
}

void UnitPlayersOfRanked(UnitPlayerArrayRef outPlayers) {
    int index;
    int k = 0;
    int i;
    int j;
    UnitPlayer tempPlayer;

    for (index = 0; index < c_unitPlayersCap; index += 1) {
        if (!arena_gf_StringIsEmpty(gv_gamestate_unitPlayers[index].name)) {
            gamestate_CopyUnitPlayer(outPlayers[k], gv_gamestate_unitPlayers[index]);
            k += 1;
        }
    }

    for (i = 0; i < gv_gamestate_unitPlayersCount-1; i += 1) {
        for (j = i+1; j < gv_gamestate_unitPlayersCount; j += 1) {
            if (outPlayers[i].score < outPlayers[j].score) {
                gamestate_CopyUnitPlayer(tempPlayer, outPlayers[i]);
                gamestate_CopyUnitPlayer(outPlayers[i], outPlayers[j]);
                gamestate_CopyUnitPlayer(outPlayers[j], tempPlayer);
            }
        } 
    }
}

void UnitPlayersGetAll(UnitPlayerArrayRef outPlayers) {
    int index;
    int k = 0;

    for (index = 0; index < c_unitPlayersCap; index += 1) {
        if (!arena_gf_StringIsEmpty(gv_gamestate_unitPlayers[index].name)) {
            gamestate_CopyUnitPlayer(outPlayers[k], gv_gamestate_unitPlayers[index]);
            k += 1;
        }
    }
}

void UnitPlayerAddBuff(UnitPlayerRef refPlayer, UnitPlayerBuffRef inBuff) {
    int lv_index;
    UnitPlayerBuffRef lv_buff;
    int lv_emptyBUffIndex = -1;
    datetime lv_now = CurrentDateTimeGet();
    for (lv_index = 0; lv_index < c_UnitPlayerBuffsCap; lv_index += 1) {
        lv_buff = refPlayer.buffs[lv_index];
        if (lv_buff.behavior == null && lv_emptyBUffIndex < 0) {
            lv_emptyBUffIndex = lv_index;
        } else if (lv_buff.behavior == inBuff.behavior) {
            lv_buff.count = inBuff.count;
            lv_buff.duration -= DateTimeToInt(lv_now) - DateTimeToInt(lv_buff.ctime);
            if (lv_buff.duration > 0) {
                lv_buff.duration += inBuff.duration;
            } else {
                lv_buff.duration = inBuff.duration;
            }
            lv_buff.ctime = lv_now;
            lv_emptyBUffIndex = -1;
            break;
        }
    }
    if (lv_emptyBUffIndex >= 0) {
        lv_buff = refPlayer.buffs[lv_emptyBUffIndex];
        lv_buff.behavior = inBuff.behavior;
        lv_buff.count = inBuff.count;
        lv_buff.duration = inBuff.duration;
        lv_buff.ctime = lv_now;
    }
}

void UnitPlayerSaveBuffs(UnitPlayerRef refPlayer) {
    int lv_index;
    UnitPlayerBuffRef lv_buff;
    datetime lv_now = CurrentDateTimeGet();
    for (lv_index = 0; lv_index < c_UnitPlayerBuffsCap; lv_index += 1) {
        lv_buff = refPlayer.buffs[lv_index];
        if (lv_buff.behavior != null) {
            lv_buff.duration -= DateTimeToInt(lv_now) - DateTimeToInt(lv_buff.ctime);
            if (lv_buff.duration <= 0) {
                lv_buff.behavior = null;
                lv_buff.count = 0;
                lv_buff.duration = 0;
            }
            lv_buff.ctime = null;
        }
    }
}

void UnitPlayerRestoreBuffs(UnitPlayerRef refPlayer, unit inUnit) {
    int lv_index;
    UnitPlayerBuffRef lv_buff;
    datetime lv_now = CurrentDateTimeGet();
    for (lv_index = 0; lv_index < c_UnitPlayerBuffsCap; lv_index += 1) {
        lv_buff = refPlayer.buffs[lv_index];
        if (lv_buff.behavior != null) {
            lv_buff.ctime = lv_now;
            UnitBehaviorAdd(inUnit, lv_buff.behavior, inUnit, lv_buff.count);
            UnitBehaviorSetDuration(inUnit, lv_buff.behavior, lv_buff.duration);
        }
    }
}

int UnitPlayerGetMinLevel() {
    int lv_index;
    int lv_minLevel = c_UnitPlayerMaxLevel - 1;
    UnitPlayerRef lv_player;

    if (gv_gamestate_unitPlayersCount <= 0) {
        return 1;
    }
    for (lv_index = 0; lv_index < c_unitPlayersCap; lv_index += 1) {
        if (!arena_gf_StringIsEmpty(gv_gamestate_unitPlayers[lv_index].name)) {
            lv_player = gv_gamestate_unitPlayers[lv_index];
            if (lv_player.level < lv_minLevel) {
                lv_minLevel = lv_player.level;
            }
        }
    }
    return lv_minLevel;
}

void InitGameState() {
    gamestate_InitUnitPlayerIndexOfName();
}