// Const Declarations
const int c_unitPlayerAIStatesCap = 10;
static const int c_gamestate_unitPlayersCap = 20;

// Type Declarations
struct UnitPlayer {
    string name;
    string unitType;
    int playerId;
    int score;
    int points;
    int aiMode;
    int[c_unitPlayerAIStatesCap] aiStates;
};

typedef structref<UnitPlayer> UnitPlayerRef;

typedef UnitPlayer[c_gamestate_unitPlayersCap] UnitPlayerArray;
typedef arrayref<UnitPlayerArray> UnitPlayerArrayRef;

// Variable Declarations
static UnitPlayerArray gv_gamestate_unitPlayers;
static int gv_gamestate_unitPlayersCount;
static int gv_gamestate_unitPlayerIndexOfName;

// Function Declarations
bool AddUnitPlayer(UnitPlayerRef player);
bool RemoveUnitPlayer(string name);
bool SaveUnitPlayer(UnitPlayerRef player);
bool UnitPlayerFromName(string name, UnitPlayerRef player);
int UnitPlayersCount();
void UnitPlayersOfRanked(UnitPlayerArrayRef players);
void InitGameState();

static void gamestate_InitUnitPlayerIndexOfName();
static void gamestate_CopyUnitPlayer(UnitPlayerRef source, UnitPlayerRef dest);
static int gamestate_PickAvailableUnitPlayerIndex();
static void gamestate_SaveUnitPlayerByIndex(int index, UnitPlayerRef player);

// Functions
static void gamestate_InitUnitPlayerIndexOfName() {
    DataTableInstanceCreate();
    gv_gamestate_unitPlayerIndexOfName = DataTableInstanceLastCreated();
}

static void gamestate_CopyUnitPlayer(UnitPlayerRef dest, UnitPlayerRef source) {
    int lv_aiStatesIndex;

    dest.name = source.name;
    dest.playerId = source.playerId;
    dest.points = source.points;
    dest.score = source.score;
    dest.unitType = source.unitType;
    dest.aiMode = source.aiMode;

    for (lv_aiStatesIndex = 0; lv_aiStatesIndex < c_unitPlayerAIStatesCap; lv_aiStatesIndex += 1) {
        dest.aiStates[lv_aiStatesIndex] = source.aiStates[lv_aiStatesIndex];
    }
}

static int gamestate_PickAvailableUnitPlayerIndex() {
    int index;

    for (index = 0; index < c_gamestate_unitPlayersCap; index += 1) {
        if (gv_gamestate_unitPlayers[index].name == null) {
            break;
        }
    }
    return index;
}

static void gamestate_SaveUnitPlayerByIndex(int index, UnitPlayerRef player) {
    gamestate_CopyUnitPlayer(gv_gamestate_unitPlayers[index], player);
    DataTableInstanceSetInt(gv_gamestate_unitPlayerIndexOfName, player.name, index);
}

bool AddUnitPlayer(UnitPlayerRef player) {
    int index = gamestate_PickAvailableUnitPlayerIndex();
    if (index == c_gamestate_unitPlayersCap) {
        return false;
    }
    gamestate_SaveUnitPlayerByIndex(index, player);
    gv_gamestate_unitPlayersCount += 1;
    return true;
}

bool RemoveUnitPlayer(string name) {
    UnitPlayer emptyPlayer;

    if (!DataTableInstanceValueExists(gv_gamestate_unitPlayerIndexOfName, name)) {
        return false;
    }
    gamestate_CopyUnitPlayer(gv_gamestate_unitPlayers[DataTableInstanceGetInt(gv_gamestate_unitPlayerIndexOfName, name)], emptyPlayer);
    DataTableInstanceValueRemove(gv_gamestate_unitPlayerIndexOfName, name);
    gv_gamestate_unitPlayersCount -= 1;
    return true;
}

bool SaveUnitPlayer(UnitPlayerRef player) {
    UnitPlayerRef lv_player;

    if (!DataTableInstanceValueExists(gv_gamestate_unitPlayerIndexOfName, player.name)) {
        return false;
    }

    lv_player = gv_gamestate_unitPlayers[DataTableInstanceGetInt(gv_gamestate_unitPlayerIndexOfName, player.name)];
    gamestate_CopyUnitPlayer(lv_player, player);
    return true;
}

bool UnitPlayerFromName(string name, UnitPlayerRef player) {
    UnitPlayerRef lv_player;

    if (!DataTableInstanceValueExists(gv_gamestate_unitPlayerIndexOfName, name)) {
        return false;
    }

    lv_player = gv_gamestate_unitPlayers[DataTableInstanceGetInt(gv_gamestate_unitPlayerIndexOfName, name)];
    gamestate_CopyUnitPlayer(player, lv_player);
    return true;
}

int UnitPlayersCount() {
    return gv_gamestate_unitPlayersCount;
}

void UnitPlayersOfRanked(UnitPlayerArrayRef players) {
    int index;
    int i;
    int j;
    UnitPlayer tempPlayer;

    for (index = 0; index < gv_gamestate_unitPlayersCount; index += 1) {
        gamestate_CopyUnitPlayer(players[index], gv_gamestate_unitPlayers[index]);
    }

    for (i = 0; i < gv_gamestate_unitPlayersCount-1; i += 1) {
        for (j = i+1; j < gv_gamestate_unitPlayersCount; j += 1) {
            if (players[i].score < players[j].score) {
                gamestate_CopyUnitPlayer(tempPlayer, players[i]);
                gamestate_CopyUnitPlayer(players[i], players[j]);
                gamestate_CopyUnitPlayer(players[j], tempPlayer);
            }
        } 
    }
}

void InitGameState() {
    gamestate_InitUnitPlayerIndexOfName();
}